<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no">
    <meta charset="utf-8">
    <meta name="author" content="Kevin P. , MITsdm'18">
    <title>SafePaths MIT</title>
    <style>
      /* Always set the map height explicitly to define the size of the div
       * element that contains the map. */
      #map {
        height: 100%;
      }
      /* Optional: Makes the sample page fill the window. */
      html, body {
        height: 100%;
        margin: 0;
        padding: 0;
      }
      #floating-panel {
        position: absolute;
        top: 10px;
        left: 10%;
        z-index: 5;
        background-color: #fff;
        padding: 5px;
        border: 1px solid #999;
        text-align: center;
        font-family: 'Roboto','sans-serif';
        line-height: 30px;
        padding-left: 10px;
      }
    </style>
  </head>
  <body>
    <div id="floating-panel">
        PrivateKit MIT Location History File: 
        <input id=privatekitJSON type=file />
        <input onclick="loadPath();" type=button value="Load Location History" />
        <input onclick="saveText();" type=button value="Save Location History" />
        <div>
            Erase Line: <input type="checkbox" id="eraser" value="true" />
            <input onclick="compress();" type=button value="Compress Data" />
        </div>
    </div>
    <div id="map"></div>
    <script>
        // This example adds a UI control allowing users to remove the polyline from the
        // map.

        var exposurePoints;
        var exposurePath;
        var exposureJSON;

        var temporalCompressionWindow = (60 * 1000); //1 minute in milliseconds
        var spatialCompressionWindow = 10; //meters
        var weightedExposurePoints;
        var weightedExposureJSON;
        var exposureHeatmap;
        var map;
        var fileRegExp = new RegExp(/\.json$/);

        function initMap() {
            map = new google.maps.Map(document.getElementById('map'), {
                zoom: 14,
                center: {lat: 42.3601, lng: -71.0942},
                mapTypeId: 'terrain'
            });
        }

        function loadPath() {
            file = document.getElementById("privatekitJSON").files[0];
            if (typeof window.FileReader !== 'function') {
                alert("The file API isn't supported on this browser yet.");
            }
            else if(file === undefined || !fileRegExp.test(file.name)){
                alert("You must choose a valid JSON file!");
            }
            else
            {
                exposurePoints = [];
                exposurePath = [];
                fr = new FileReader();
                fr.onload = (function(map, points, path){
                    return function(event){
                        let lines = event.target.result;
                        let lastLatLng = null;
                        exposureJSON = JSON.parse(lines);

                        exposureJSON.forEach(function(element, index){
                            elementLatLng = new google.maps.LatLng(element.latitude, element.longitude);

                            let marker = new google.maps.Marker({
                                position: elementLatLng,
                                label: 'ID:' + element.id,
                                title: new Date(element.time * 1000).toLocaleString(),
                                map: map
                            });

                            google.maps.event.addListener(marker,'click',function(event){
                                if($("#eraser").prop("checked"))
                                {
                                    editExposure(event,this);
                                }
                            });

                            points.push(marker);

                            if(index == 0){
                                map.setCenter(elementLatLng);
                            }
                            else
                            {
                                let polylinePath = new google.maps.Polyline({
                                    path: [lastLatLng, elementLatLng],
                                    strokeColor: '#FF0000',
                                    strokeOpacity: 1.0,
                                    strokeWeight: 2,
                                });
                                path.push(polylinePath);
                                addLine(polylinePath);
                            }
                            lastLatLng = elementLatLng;
                        });
                    }
                })(map, exposurePoints, exposurePath);
                fr.readAsText(file);
            }
        }

        function addPoint(marker) {
            point.setMap(map);
        }

        function addLine(polyline) {
            polyline.setMap(map);
        }

        function removePoint(marker) {
            if(marker !== undefined && marker !== null)
            {
                marker.setMap(null);   
            }
        }

        function removeLine(polyline) {
            if(polyline !== undefined && polyline !== null)
            {
                polyline.setMap(null);
            }
        }

        function deletePoint(marker) {
            marker = null;
        }

        function deleteLine(polyline) {
            polyline = null;
        }
        
        function editExposure(event, marker)
        {
            let i = 0;
            let bFoundPath = false;

            //DANGER: loop condition uses shortcutting and in-place incrementing in order to work!
            do
            {
                if(exposurePoints[i] === marker)
                {
                    bFoundPath = true;
                }
            }
            while(!bFoundPath && ++i < exposurePoints.length)
            if(bFoundPath)
            {
                deleteExposure(i,marker);
            }
        }

        function deleteExposure(i,marker){
            if(exposurePath.length > 0)
            {
                //remove the line leading FROM the marked point, if it exists, and delete the object
                if(i < exposurePoints.length-1)
                {
                    removeLine(exposurePath[i]);
                    deleteLine(exposurePath[i]);
                    exposurePath.splice(i,1);
                }

                //remove the line leading TO the marked point, if it exists, and delete the object
                if(i > 0)
                {
                    removeLine(exposurePath[i-1]);
                    deleteLine(exposurePath[i-1]);
                    exposurePath.splice(i-1,1);
                }
            }

            //remove the marker from the map and delete the object
            removePoint(marker);
            deletePoint(marker);
            exposurePoints.splice(i,1);
            exposureJSON.splice(i,1);
        }

        function saveText(){
            let redactedJSON = exposureJSON;
            if(weightedExposureJSON !== undefined && weightedExposureJSON !== null)
            {
                redactedJSON = weightedExposureJSON;
            }
            let text = JSON.stringify(redactedJSON);
            let file = document.getElementById("privatekitJSON").files[0];
            let filename = file.name.replace(fileRegExp, "-REDACTED.json");
            var a = document.createElement('a');
            a.setAttribute('href', 'data:text/plain;charset=utf-8,'+encodeURIComponent(text));
            a.setAttribute('download', filename);
            a.click();
        }

        class WeightedLocation {
            constructor(LatLng, weight) {
                this.location = LatLng;
                this.weight = weight;
            }
        }

        function compress(){
            if(exposureJSON !== undefined && exposureJSON !== null)
            {
                weightedExposurePoints = [];
                weightedExposureJSON = [];

                let weightIncrement = 0.5; //how much each point contributes to the compressed weight
                let lastPoint = null;
                let lastPointWeight = weightIncrement;

                let removedIndicies = [];

                exposureJSON.forEach(function(element,index){
                    elementLatLng = new google.maps.LatLng(element.latitude, element.longitude);

                    if(lastPoint !== null)
                    {
                        lastElementLatLng = new google.maps.LatLng(lastPoint.latitude, lastPoint.longitude);
                    }

                    //reduce to temporal and special resolution
                    if(
                        (lastPoint !== null && lastElementLatLng !== null)
                            &&
                        (element.time - lastPoint.time <= temporalCompressionWindow)
                            &&
                        (Math.abs(google.maps.geometry.spherical.computeDistanceBetween(lastElementLatLng,elementLatLng)) <= spatialCompressionWindow)
                    )
                    {
                        //increase the weight of the last point we are going to use as we compress within the windows
                        lastPointWeight += weightIncrement;

                        //add the index for removal of the compressed points from the map
                        removedIndicies.push(index);
                    }
                    else
                    {
                        if(lastPoint !== null && lastElementLatLng !== null)
                        {
                            //create the weighted data point
                            let weighthedExposurePoint = new WeightedLocation(lastElementLatLng, lastPointWeight);

                            //keep traction on the JSON and weighted points we are using
                            weightedExposureJSON.push(lastPoint);
                            weightedExposurePoints.push(weighthedExposurePoint);
                        }

                        //we only move the last point when we're done compressing all points in the window of the previous last element
                        lastPoint = element;
                    }
                });

                //finally, don't forget to include the last point!  It was either just set as a compression point or just had another point compressed into it and not yet turned into a WeightedLocation.
                if(lastPoint !== null && lastElementLatLng !== null)
                {
                    //create the weighted data point
                    let weighthedExposurePoint = new WeightedLocation(lastElementLatLng, lastPointWeight);

                    //keep traction on the JSON and weighted points we are using
                    weightedExposureJSON.push(lastPoint);
                    weightedExposurePoints.push(weighthedExposurePoint);
                }

                let i = 0;
                while(i = removedIndicies.pop())
                {
                    deleteExposure(i,exposurePoints[i]);
                }

                //remove any only compression data
                if(exposureHeatmap !== undefined && exposureHeatmap !== null){
                    exposureHeatmap.setMap(null);
                    exposureHeatmap = null;
                }

                exposureHeatmap = new google.maps.visualization.HeatmapLayer({
                    data: weightedExposurePoints
                });
                exposureHeatmap.setMap(map);
            }
        }
    </script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
    <script async defer src="https://maps.googleapis.com/maps/api/js?key=[YOUR API KEY HERE]&callback=initMap"></script>
  </body>
</html>