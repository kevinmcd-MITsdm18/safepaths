<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no">
    <meta charset="utf-8">
    <meta name="author" content="Kevin P. , MITsdm'18">
    <title>SafePaths MIT</title>
    <style>
      /* Always set the map height explicitly to define the size of the div
       * element that contains the map. */
      #map {
        height: 100%;
      }
      /* Optional: Makes the sample page fill the window. */
      html, body {
        height: 100%;
        margin: 0;
        padding: 0;
      }
      #floating-panel {
        position: absolute;
        top: 10px;
        left: 1%;
        z-index: 5;
        background-color: #fff;
        padding: 5px;
        border: 1px solid #999;
        text-align: center;
        font-family: 'Roboto','sans-serif';
        line-height: 30px;
        padding-left: 10px;
      }
    </style>
  </head>
  <body>
    <div id="floating-panel">
        PrivateKit MIT Location History File: <input id=privatekitJSON type=file /> <br />
        <input onclick="loadPath();" type=button value="Load Location History" />
        <input onclick="saveText();" type=button value="Save Location History" />
        <div>
            <div>Erase Line: <input type="checkbox" id="eraser" value="true" /></div>
            <div>
                <div>
                    Temporal Compression Window (min): <input id="temporalWindow" onchange="updateCompressionWindow();" type=input value="1" size="2" /><br />
                    Spatial Compression Window (meters): <input id="spatialWindow" onchange="updateCompressionWindow();" type=input value="10" size="2" />
                </div>
                <div>
                    <input onclick="heatmap();" type=button value="Compress Data" />
                    <input onclick="unheatmap();" type=button value="Uncompress Data" />
                </div>
            </div>
        </div>
    </div>
    <div id="map"></div>
    <script>
        // This example adds a UI control allowing users to remove the polyline from the
        // map.

        var exposurePoints;
        var exposurePaths;
        var exposureJSON;

        var temporalCompressionWindow = (60 * 1000); //1 minute in milliseconds
        var spatialCompressionWindow = 10; //meters
        var exposureHeatmap;
        var map;
        var fileRegExp = new RegExp(/\.json$/);

        function initMap() {
            map = new google.maps.Map(document.getElementById('map'), {
                zoom: 14,
                center: {lat: 42.3601, lng: -71.0942},
                mapTypeId: 'terrain'
            });
            updateCompressionWindow();
        }

        function updateCompressionWindow(){
            let temporalWindowValue = $("#temporalWindow").val();
            let spatialWindowValue = $("#spatialWindow").val();
            temporalCompressionWindow = (temporalWindowValue * 60 * 1000); //X minutes in milliseconds
            spatialCompressionWindow = spatialWindowValue; //Y meters
            console.log("Set spatial-temporal compression window to "+ spatialCompressionWindow +" meters & "+ temporalCompressionWindow +" milliseconds");
        }

        function clearMap(){
            clearMarkers();
            clearPolylines();
            clearHeatmap();
        }

        function clearMarkers(){
            if(exposurePoints !== undefined && exposurePoints !== null){
                exposurePoints.forEach(function(element,index){
                    if(element !== undefined && element !== null){
                        deleteMarker(element);
                    }
                });
                exposurePoints = null;
            }
        }

        function deleteMarker(marker) {
            removePoint(marker);
            marker = null;
        }

        function clearPolylines(){
            if(exposurePaths !== undefined && exposurePaths !== null){
                exposurePaths.forEach(function(element,index){
                    if(element !== undefined && element !== null){
                        deletePolyline(element);
                    }
                });
                exposurePaths = null;
            }
        }

        function deletePolyline(polyline) {
            removeLine(polyline);
            polyline = null;
        }

        function clearHeatmap()
        {
            //remove any old compression data
            if(exposureHeatmap !== undefined && exposureHeatmap !== null){
                exposureHeatmap.setMap(null);
                exposureHeatmap = null;
            }   
        }

        function loadPath() {
            
            file = document.getElementById("privatekitJSON").files[0];
            if (typeof window.FileReader !== 'function') {
                alert("The file API isn't supported on this browser yet.");
            }
            else if(file === undefined || !fileRegExp.test(file.name)){
                alert("You must choose a valid JSON file!");
            }
            else
            {
                clearMap();
                exposurePoints = [];
                exposurePaths = [];
                exposureJSON = null;

                fr = new FileReader();
                fr.onload = (function(map, points, path){
                    return function(event){
                        let lines = event.target.result;
                        let lastLatLng = null;
                        exposureJSON = JSON.parse(lines);

                        exposureJSON.forEach(function(element, index){
                            elementLatLng = new google.maps.LatLng(element.latitude, element.longitude);

                            let marker = new google.maps.Marker({
                                position: elementLatLng,
                                label: 'ID:' + element.id,
                                title: new Date(element.time * 1000).toLocaleString(),
                                map: map
                            });

                            google.maps.event.addListener(marker,'click',function(event){
                                if($("#eraser").prop("checked"))
                                {
                                    editExposure(event,this);
                                }
                            });

                            points.push(marker);

                            if(index == 0){
                                map.setCenter(elementLatLng);
                            }
                            else
                            {
                                let polylinePath = new google.maps.Polyline({
                                    path: [lastLatLng, elementLatLng],
                                    strokeColor: '#FF0000',
                                    strokeOpacity: 1.0,
                                    strokeWeight: 2,
                                });
                                path.push(polylinePath);
                                addLine(polylinePath);
                            }
                            lastLatLng = elementLatLng;
                        });
                    }
                })(map, exposurePoints, exposurePaths);
                fr.readAsText(file);
            }
        }

        function addPoint(marker) {
            marker.setMap(map);
        }

        function addLine(polyline) {
            polyline.setMap(map);
        }

        function removePoint(marker) {
            if(marker !== undefined && marker !== null)
            {
                marker.setMap(null);   
            }
        }

        function removeLine(polyline) {
            if(polyline !== undefined && polyline !== null)
            {
                polyline.setMap(null);
            }
        }
        
        function editExposure(event, marker)
        {
            let i = 0;
            let bFoundPath = false;

            //DANGER: loop condition uses shortcutting and in-place incrementing in order to work!
            do
            {
                if(exposurePoints[i] === marker)
                {
                    bFoundPath = true;
                    deleteExposure(i,marker, DELETION_ACTION.EDIT);
                }
            }
            while(!bFoundPath && ++i < exposurePoints.length)

            //redo the heatmap if it is available
            if(exposureHeatmap !== undefined && exposureHeatmap !== null)
            {
                heatmap();
            }
        }

        const DELETION_ACTION = {EDIT: 0, COMPRESS: 1};

        function deleteExposure(i,marker,action){
            try
            {
                //handle the exposure data
                switch (action) {
                    case DELETION_ACTION.EDIT:
                        exposureJSON[i].suppress = true;
                        break;
                    case DELETION_ACTION.COMPRESS:
                        exposureJSON[i].compress = true;
                        break;
                    default:
                        throw("Illegal attempt to delete an exposure point!");
                }

                if(exposurePaths.length > 0)
                {
                    //remove the line leading FROM the marked point, if it exists, and delete the object
                    if(i < exposurePoints.length-1)
                    {
                        removeLine(exposurePaths[i]);
                    }

                    //remove the line leading TO the marked point, if it exists, and delete the object
                    if(i > 0)
                    {
                        removeLine(exposurePaths[i-1]);
                    }
                }

                //remove the marker from the map and delete the object
                removePoint(marker);
            }
            catch(exception){
                alert(exception);
            }
        }

        function addExposure(i,marker){
            if(exposurePaths.length > 0)
            {
                //remove the line leading FROM the marked point, if it exists, and delete the object
                if(i < exposurePoints.length-1)
                {
                    addLine(exposurePaths[i]);
                }

                //remove the line leading TO the marked point, if it exists, and delete the object
                if(i > 0)
                {
                    addLine(exposurePaths[i-1]);
                }
            }

            //remove the marker from the map and delete the object
            addPoint(marker);
        }

        function isExposureRedacted(element)
        {
            return !(
                    (element.suppress === undefined || element.suppress === null || element.suppress == false)
                    &&
                    (element.compress === undefined || element.compress === null || element.compress == false)
                );
        }

        function saveText(){
            let redactedJSON = [];
            
            exposureJSON.forEach(function(element,index){
                if(!isExposureRedacted(element))
                {
                    redactedJSON.push(element);
                }
            });
            
            let text = JSON.stringify(redactedJSON);
            let file = document.getElementById("privatekitJSON").files[0];
            let filename = file.name.replace(fileRegExp, "-REDACTED.json");
            var a = document.createElement('a');
            a.setAttribute('href', 'data:text/plain;charset=utf-8,'+encodeURIComponent(text));
            a.setAttribute('download', filename);
            a.click();
        }

        class WeightedLocation {
            constructor(LatLng, weight) {
                this.location = LatLng;
                this.weight = weight;
            }
        }

        function heatmap()
        {
            if(exposureJSON !== undefined && exposureJSON !== null)
            {
                compress();

                let weightedExposurePoints = [];
                
                exposureJSON.forEach(function(element,index){
                    if(!isExposureRedacted(element))
                    {
                        //create the weighted data point
                        let elementLatLng = new google.maps.LatLng(element.latitude, element.longitude);
                        let weighthedExposurePoint = new WeightedLocation(elementLatLng, element.weight);
                        weightedExposurePoints.push(weighthedExposurePoint);
                    }
                });

                clearHeatmap();

                exposureHeatmap = new google.maps.visualization.HeatmapLayer({
                    data: weightedExposurePoints
                });
                exposureHeatmap.setMap(map);
            }
        }

        function compress(){
            if(exposureJSON !== undefined && exposureJSON !== null)
            {
                doCompress = function(element, weight){
                    element.suppress = false;
                    element.compress = false;
                    element.weight = weight;
                };
                updateCompressionWindow();
                let weightIncrement = 0.5; //how much each point contributes to the compressed weight
                let lastPoint = null;
                let lastPointWeight = weightIncrement;

                exposureJSON.forEach(function(element,index){
                    if(element.suppress === undefined || element.suppress === null || element.suppress === false)
                    {
                        elementLatLng = new google.maps.LatLng(element.latitude, element.longitude);

                        if(lastPoint !== null)
                        {
                            lastElementLatLng = new google.maps.LatLng(lastPoint.latitude, lastPoint.longitude);

                            //reduce to temporal and special resolution
                            if(
                                (element.time - lastPoint.time <= temporalCompressionWindow)
                                    &&
                                (Math.abs(google.maps.geometry.spherical.computeDistanceBetween(lastElementLatLng,elementLatLng)) <= spatialCompressionWindow)
                            )
                            {
                                //increase the weight of the last point we are going to use as we compress within the windows
                                lastPointWeight += weightIncrement;

                                //add the index for removal of the compressed points from the map
                                deleteExposure(index,exposurePoints[index],DELETION_ACTION.COMPRESS);
                            }
                            else
                            {
                                //setup our point, it should not be supressed nor compresse and needs to know its weight
                                doCompress(lastPoint, lastPointWeight);
                                //we only move the last point when we're done compressing all points in the window of the previous last element
                                lastPoint = element; //set the new compression element
                                lastPointWeight = weightIncrement; //reset for the new compression element
                            }
                        }
                        else
                        {
                            lastPoint = element;
                        }

                        //finally, don't forget to include the last point!  It was either just set as a compression point or just had another point compressed into it and not yet turned into a WeightedLocation.
                        doCompress(lastPoint, lastPointWeight);
                    }
                });
            }
        }

        function unheatmap()
        {
            uncompress();
            clearHeatmap();
        }

        function uncompress(){
            if(exposureJSON !== undefined && exposureJSON !== null)
            {
                exposureJSON.forEach(function(element,index){
                    if(
                        (element.suppress === undefined || element.suppress === null || element.suppress == false)
                            &&
                        (element.compress !== undefined && element.compress !== null && element.compress == true)
                    )
                    {
                        //add the index for removal of the compressed points from the map
                        addExposure(index,exposurePoints[index]);
                        //setup our point, it should not be supressed nor compresse and needs to know its weight
                        element.suppress = false;
                        element.compress = false;
                        element.weight = 0;
                    }
                });
            }
        }
    </script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
    <script async defer src="https://maps.googleapis.com/maps/api/js?key=[YOUR API KEY HERE]&callback=initMap"></script>
  </body>
</html>